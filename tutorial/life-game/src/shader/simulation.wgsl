//
// コンピューティングシェーダー
//
// 頂点シェーダー、フラグメントシェーダーとは異なり、入力と出力のセットが特定のものに定められていない
// このシェーダーは、ストレージ バッファなどの任意のソースとの間でデータを読み書きする処理を担う
// そのため、各頂点、インスタンス、またはピクセルごとに1回実行される仕組みにはなっておらず、シェーダー関数を何回呼び出すのかを自身で指定する必要がある
// シェーダーが実行されると、どの呼び出しが処理されているかを識別する値が渡されるので、どのデータにアクセスして、どのような操作を行うかを決定できる
//
// GPUは3Dグラフィックに使用されることが多いため、X、Y、Z軸に沿って特定の回数だけコンピューティングシェーダーを呼び出すようにリクエストできる構造となっている
// そのため、2次元または3次元グリッドに沿った形で簡単に処理をディスパッチできるようになっている
//
// シミュレーションの各セルに対して一度、つまり合計でGRID_SIZE x GRID_SIZE回このシェーダーを呼び出す必要がある
//

// ユニフォームを使用してグリッドサイズを確認
@group(0) @binding(0) var<uniform> grid: vec2f;

// ストレージバッファとしてセル状態を公開
// - コンピューティングシェーダーには、頂点の位置やフラグメントの色などの必須の出力がないため、コンピューティングシェーダーから結果を取得するためには、ストレージバッファやテクスチャに値を書き込む必要がある
// - Ping-pongパターンを使用して、グリッドの現在の状態を入力するためのストレージバッファを1つと、グリッドの新しい状態を書き出すストレージ バッファを1つ用意する
@group(0) @binding(1) var<storage> cell_state_in: array<u32>; // 読み取り専用
@group(0) @binding(2) var<storage, read_write> cell_state_out: array<u32>; // バッファへの読み書きが可能

struct ComputeInput {
  // シェーダー呼び出しのグリッドの位置を伝える符号なし整数の3次元ベクトル
  // - このシェーダーは、グリッド内の各セルに対して一度実行する
  // - (0, 0, 0)、(1, 0, 0)、(1, 1, 0) という数値を (31, 31, 0) まで取得できるため、処理を行うセルのインデックスとして扱うことができる
  @builtin(global_invocation_id) cell: vec3u,
}

// セルのインデックスをストレージバッファの1次元の配列にマッピングする方法が必要
// これは、1次元のinstance_indexを2次元のグリッドセルにマッピングした頂点シェーダーの処理と逆の処理となる
fn cellIndex(cell: vec2u) -> u32 {
  // セルのY軸の値をグリッドの幅で乗算し、セルのX軸の値を加算
  return cell.y * u32(grid.x) + cell.x;
}

//
// ワークグループ
//
// GPUハードウェアアーキテクチャの性質上、グリッドはいくつかのワークグループに分割して処理される
// 単一のワークグループに含まれるシェーダーの呼び出しでは、高速なメモリを共有し、特定のタイプの同期プリミティブを使用できる
//
// ワークグループにはX、Y、Zのサイズがあり、それぞれを1にしても問題なく動作するが、GPUが持つシェーダーの並列実行性能を十分発揮できない
// ワークグループのサイズを大きくすることで、GPUが処理を分割し、効率的に並列実行できるようになる
//
// 各GPUには、理論上最適なワークグループのサイズがある
// しかし、WebGPUでは公開されていないアーキテクチャ上の詳細に依存するため、通常は、シェーダーの要件に応じて適切な数を選択する
// そのような要件がない場合は、WebGPUのコンテンツがさまざまなハードウェアで実行される可能性があることを考慮し、サイズを64にすることが推奨される
// 64であればハードウェアの制限を超えてしまうことは考えづらい一方で、十分な大きさのバッチで並列実行できるため、ある程度の効率性も見込める
//（ 8 x 8 = 64 なので、ここではこの推奨に従ってワークグループのサイズを設定する）
//

@compute
// このシェーダーでは、ワークグループを8 x 8のサイズにする
@workgroup_size(8, 8) // Zはデフォルトの1
fn cp_main(in: ComputeInput) {
  // セルが現在アクティブなら非アクティブに、非アクティブならアクティブにする
  if (cell_state_in[cellIndex(in.cell.xy)] == 1) {
    cell_state_out[cellIndex(in.cell.xy)] = 0;
  } else {
    cell_state_out[cellIndex(in.cell.xy)] = 1;
  }
}
